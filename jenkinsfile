pipeline {
  agent { label 'jenkins-agent' }

  environment {
    APP_NAME      = 'devsecops2-challenge'
    REGISTRY_HOST = '10.25.157.175:32030'
    IMAGE_ROOT    = "${REGISTRY_HOST}/docker-hosted"
  }

  stages {

    /* ───────────────────────  SOURCE + BUILD  ─────────────────────── */
    stage('Checkout') {
      steps {
        git url: 'https://github.com/pranesh6hpe/devsecops2-challenge.git',
            branch: 'main',
            credentialsId: 'git-https'
      }
    }

    stage('Build & Test') {
      steps {
        sh 'mvn clean verify -DskipITs'
      }
    }

    /* ─────────────────────────────  SONAR  ─────────────────────────── */
    stage('SonarQube Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
          withSonarQubeEnv('SonarQube') {
            sh '''
              mvn sonar:sonar \
                -Dsonar.projectKey=${APP_NAME} \
                -Dsonar.token=${SONAR_TOKEN}
            '''
          }
        }
      }
    }

    stage('Quality Gate') {
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: true
        }
      }
    }

    /* ───────────────────────  BUILD & PUSH IMAGE  ──────────────────── */
    stage('Build & Push Image') {
      steps {
        script {
          env.IMAGE_TAG = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE     = "${IMAGE_ROOT}/${APP_NAME}:${IMAGE_TAG}"

          withCredentials([usernamePassword(credentialsId: 'nexus-cred',
                                            usernameVariable: 'NEXUS_USER',
                                            passwordVariable: 'NEXUS_PW')]) {
            sh '''
              echo "🛠  Building $IMAGE"
              docker build --security-opt seccomp=unconfined -t "$IMAGE" .

              echo "🔐  Logging into Nexus (plain HTTP)"
              echo "$NEXUS_PW" | docker login --tls-verify=false \
                   --username "$NEXUS_USER" --password-stdin "$REGISTRY_HOST"

              echo "📤  Pushing $IMAGE"
              docker push --tls-verify=false "$IMAGE"
            '''
          }
        }
      }
    }

    /* ────────────────────────  TRIVY IMAGE SCAN  ───────────────────── */
    stage('Trivy Image Scan') {
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'nexus-cred',
                                            usernameVariable: 'NEXUS_USER',
                                            passwordVariable: 'NEXUS_PW')]) {
            sh '''
              IMAGE=${IMAGE_ROOT}/${APP_NAME}:${IMAGE_TAG}
              echo "🔎  Trivy scanning $IMAGE"
              trivy image \
                --username  "$NEXUS_USER" \
                --password  "$NEXUS_PW" \
                --insecure \
                --ignore-unfixed \
                --severity HIGH,CRITICAL \
                --exit-code 1 \
                "$IMAGE"
            '''
          }
        }
      }
    }

    /* ────────────────  COLLECT TRIVY OPERATOR REPORTS  ─────────────── */
    stage('Collect Trivy Reports') {
      steps {
        sh '''
          kubectl -n trivy-system get vulnerabilityreports.aquasecurity.github.io -o yaml > vulnerability-reports.yaml
          kubectl -n trivy-system get configauditreports.aquasecurity.github.io   -o yaml > configaudit-reports.yaml

          kubectl -n dev get vulnerabilityreports.aquasecurity.github.io -o yaml   >> vulnerability-reports.yaml || true
          kubectl -n dev get configauditreports.aquasecurity.github.io   -o yaml   >> configaudit-reports.yaml    || true

          echo '---' > combined-trivy-report.yaml
          cat vulnerability-reports.yaml >> combined-trivy-report.yaml
          echo '---'                     >> combined-trivy-report.yaml
          cat configaudit-reports.yaml   >> combined-trivy-report.yaml
        '''
        archiveArtifacts artifacts: '*.yaml', fingerprint: true
      }
    }

    /* ───────────────────  AI RELEASE NOTES (GROQ)  ─────────────────── */
    stage('AI Release Notes (Groq)') {
  when { expression { currentBuild.currentResult == 'SUCCESS' } }
  steps {
    withCredentials([string(credentialsId: 'groq-key', variable: 'GROQ_API_KEY')]) {
      sh '''
        set -e
        # Get last 200 commit messages
        git --no-pager log -n 200 --pretty=format:"%h %<(72,trunc)%s" > commits.txt

        python3 - <<'PY'
import subprocess, sys, os, pathlib, textwrap

# One-time SDK install
subprocess.run([sys.executable, "-m", "pip", "install", "--quiet", "--user", "openai>=1.13.3"], check=True)

import openai

client = openai.OpenAI(
    base_url="https://api.groq.com/openai/v1",
    api_key=os.environ["GROQ_API_KEY"]
)

commits_path = pathlib.Path("commits.txt")
if not commits_path.exists() or not commits_path.read_text().strip():
    print("No commits found – skipping AI release notes"); sys.exit(0)

commits = commits_path.read_text()
SYSTEM = textwrap.dedent(\"\"\"\
You are an expert technical writer and changelog specialist.
Your job is to generate *developer-focused release notes* based on Git commit messages.
Write a markdown changelog grouped by category such as:

### Features
- ...
### Fixes
- ...
### Infra / CI
- ...
### Security
- ...
### Tests
- ...

Avoid "misc" or "chore" unless absolutely necessary. Exclude commits like "merge", "fix typo", or "update README".

Requirements:
- Prioritize technical clarity and usefulness.
- Mention file names or modules where possible.
- Combine related commits.
- Highlight security, performance, or deployment changes.
- Use bullet points. Limit to ~200 words.
\"\"\")

USER = f"Git commits since last release:\\n```\\n{commits}\\n```"

resp = client.chat.completions.create(
    model="llama3-70b-8192",
    temperature=0.3,
    messages=[
        {"role": "system", "content": SYSTEM},
        {"role": "user",   "content": USER}
    ]
)

notes = resp.choices[0].message.content.strip()
print("\\n===== AI-Generated Release Notes =====\\n")
print(notes)
pathlib.Path("release-notes.md").write_text(notes + "\\n")
PY
      '''
      archiveArtifacts artifacts: 'release-notes.md', fingerprint: true
    }
  }
}

    /* ───────────────────────────  DEPLOY DEV  ───────────────────────── */
    stage('Deploy to DEV') {
      steps {
        sh '''
          echo "🚀  Deploying $APP_NAME:${IMAGE_TAG} to dev"
          helm upgrade --install "$APP_NAME" chart \
            --namespace dev --create-namespace \
            --set image.repository=$IMAGE_ROOT/$APP_NAME \
            --set image.tag=$IMAGE_TAG \
            --set imagePullSecrets[0].name=nexus-pull \
            --set service.type=NodePort \
            --set service.nodePort=32007
        '''
      }
    }

    /* ────────────────  MANUAL APPROVAL & PROD DEPLOY  ──────────────── */
    stage('Approval to PROD') {
      steps { input message: "Deploy ${APP_NAME}:${IMAGE_TAG} to PROD?" }
    }

    stage('Deploy to PROD') {
      steps {
        sh '''
          echo "🚀  Deploying $APP_NAME:${IMAGE_TAG} to prod"
          helm upgrade --install "$APP_NAME" chart \
            --namespace prod --create-namespace \
            --set image.repository=$IMAGE_ROOT/$APP_NAME \
            --set image.tag=$IMAGE_TAG \
            --set imagePullSecrets[0].name=nexus-pull \
            --set service.type=NodePort \
            --set service.nodePort=32008
        '''
      }
    }
  }

  /* ─────────────────────────  POST ACTIONS  ────────────────────────── */
  post {
    always  { cleanWs() }

    success {
      script {
        def gitEmail = env.GIT_COMMITTER_EMAIL ?: 'default-team@example.com'
        mail to: gitEmail,
             subject: "${env.JOB_NAME} #${env.BUILD_NUMBER} ✓",
             body:    "Build succeeded — see details at ${env.BUILD_URL}"
      }
    }

    failure {
      script {
        def gitEmail = env.GIT_COMMITTER_EMAIL ?: 'default-team@example.com'
        mail to: gitEmail,
             subject: "${env.JOB_NAME} #${env.BUILD_NUMBER} ✗",
             body:    "Build failed — investigate console output:\n${env.BUILD_URL}"
      }
    }
  }
}
